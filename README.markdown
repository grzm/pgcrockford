# pgcrockford - Crockford Base32 encoding for PostgreSQL unsigned integers

The pgcrockford extension provides Base 32 encoded integers as a
PostgreSQL base type. From [Douglas Crockford's
requirements][crockford] for the specification, the encoding should

> - Be human readable and machine readable.
> - Be compact. Humans have difficulty in manipulating long strings of arbitrary symbols.
> - Be error resistant. Entering the symbols must not require keyboarding gymnastics.
> - Be pronounceable. Humans should be able to accurately transmit the symbols to other humans using a telephone.

[crockford]: https://www.crockford.com/wrmg/crockford.html

The motivation for `pgcrockford` is to provide a more humane display of
values used for surrogate keys while preserving the efficiency of an
integer implementation: `crockford` values are represented as
alpha-numeric strings while using unsigned integers for their
implementation.

## Releases and Dependencies

Latest release: 0.9.0

Tested with PostgreSQL 11.

## Installation

    make
    make install
    make installcheck

```sql
CREATE SCHEMA crockford;
CREATE EXTENSION crockford WITH SCHEMA crockford;
```

> Note: The extension doesn't require a dedicated schema, but it's
> good practice to utilize schemas to namespace modules.


## Usage

The `pgcrockford` extension provides 3 base types: 2-byte, 4-byte, and
8-byte implementations.

 - `crockford2` (2-byte)
 - `crockford4` (4-byte)
 - `crockford8` (8-byte)

```sql
SELECT 10::crockford.crockford4;
-- A

SELECT '10'::crockford.crockford4;
-- 10

SELECT ('A'::crockford.crockford4 + 1)::crockford.crockford4;
-- B
```

```sql
CREATE TABLE store.widgets (
  widget_id crockford.crockford4 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  widget_name text UNIQUE NOT NULL
);

INSERT INTO store.widgets (widget_name)
  SELECT 'widget' || n FROM generate_series(1,64) AS _ (n);

SELECT * FROM store.widgets ORDER BY widget_id DESC LIMIT 10;
/*
 widget_id | widget_name
-----------+-------------
 20        | widget64
 1Z        | widget63
 1Y        | widget62
 1X        | widget61
 1W        | widget60
 1V        | widget59
 1T        | widget58
 1S        | widget57
 1R        | widget56
 1Q        | widget55
(10 rows)
*/
```

### Getting funky with representation

One of the drawbacks of using sequences as surrogate keys is that
there's nothing to distinguish an id value of one table from an id
value of another. If both `store.widget` and `store.locations` have
`id` surrogate key columns, is `1232` a `widget_id` or a
`location_id`? Setting aside debates of whether one should use
surrogate keys or column naming conventions, you can leverage the
alpha-numeric representation of the `crockford` types to encode the
type in the id value.

```sql
CREATE FUNCTION store.next_widget_id()
RETURNS crockford.crockford4
LANGUAGE sql AS
$body$
  SELECT 'W00000' + nextval('store.widgets_widget_id_seq');
$body$;

CREATE FUNCTION store.next_location_id()
RETURNS crockford.crockford4
LANGUAGE sql AS
$body$
  SELECT 'L00000' + nextval('store.locations_location_id_seq');
$body$;
```

These functions will provide 33,554,431 unique values each
(`W00001`..`WZZZZZ` and `L00001`..`LZZZZZ` respectively) before
encroaching on the encoded "type".


## Thanks!

The `pgcrockford` extension takes inspiration from Peter Eisentraut's
`[pguint][]` library, both for using unisigned integers as the
underlying implementation and also for generating some of the code
that implements it (see [generate.py][generate.py]).

I also found Manuel Kniep's series (parts [1][adjust-ext-1],
[2][adjust-ext-2], and [3][adjust-ext-3], [4][adjust-ext-4], and
[5][adjust-ext]5]) on writing PostgreSQL Extensions useful as
well--and not only because it focused on writing `[pg-base36][]`.

[pguint]: https://github.com/petere/pguint

[adjust-ext-1]: http://big-elephants.com/2015-10/writing-postgres-extensions-part-i/
[adjust-ext-2]: http://big-elephants.com/2015-10/writing-postgres-extensions-part-ii/
[adjust-ext-3]: http://big-elephants.com/2015-10/writing-postgres-extensions-part-iii/
[adjust-ext-4]: http://big-elephants.com/2015-11/writing-postgres-extensions-part-iv/
[adjust-ext-5]: http://big-elephants.com/2015-11/writing-postgres-extensions-part-v/
[pg-base36]: https://github.com/adjust/pg-base36


## Licence

Released under the PostgreSQL License

Â© 2018, Michael Glaesemann

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written
agreement is hereby granted, provided that the above copyright notice
and this paragraph and the following two paragraphs appear in all
copies.

IN NO EVENT SHALL MICHAEL GLAESEMANN BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
DOCUMENTATION, EVEN IF MICHAEL GLAESEMANN HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

MICHAEL GLAESEMANN SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS
IS" BASIS, AND MICHAEL GLAESEMANN HAS NO OBLIGATIONS TO PROVIDE
MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
